use std::{
    env,
    sync::{OnceLock, atomic::AtomicU32},
};

use anyhow::Result;
use inquire::{Select, Text};
use integration_tests::paths::integration_tests_root;
use serde::{Deserialize, Serialize};
use serde_json::json;
use strum::{Display, EnumIter, IntoEnumIterator};
use tracing::error;

use crate::{
    inputs::{InputHandle, filter_video_inputs},
    outputs::{AudioEncoder, OutputHandle, VideoEncoder, VideoResolution, scene::Scene},
};

const WHEP_TOKEN_ENV: &str = "WHEP_OUTPUT_BEARER_TOKEN";

#[derive(Debug, Display, EnumIter, Clone)]
pub enum WhepRegisterOptions {
    #[strum(to_string = "Set video stream")]
    SetVideoStream,

    #[strum(to_string = "Set audio stream")]
    SetAudioStream,

    #[strum(to_string = "Skip")]
    Skip,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WhepOutput {
    name: String,
    bearer_token: String,
    video: Option<WhepOutputVideoOptions>,
    audio: Option<WhepOutputAudioOptions>,
}

#[typetag::serde]
impl OutputHandle for WhepOutput {
    fn name(&self) -> &str {
        &self.name
    }

    fn serialize_register(&self, inputs: &[&dyn InputHandle]) -> serde_json::Value {
        json!({
            "type": "whep_server",
            "bearer_token": self.bearer_token,
            "video": self.video.as_ref().map(|v| v.serialize_register(inputs)),
            "audio": self.audio.as_ref().map(|a| a.serialize_register(inputs)),
        })
    }

    fn on_after_registration(&mut self) -> Result<()> {
        let html_path = integration_tests_root().join("examples/demo/whep.html");

        let url = format!(
            "file://{}?url=http://127.0.0.1:9000/whep/{}&token={}",
            html_path.to_str().unwrap(),
            self.name,
            self.bearer_token
        );

        println!("Instructions to start receiving stream:");
        println!("Open in browser:");
        println!("{url}");
        Ok(())
    }

    fn serialize_update(&self, inputs: &[&dyn InputHandle]) -> serde_json::Value {
        json!({
           "video": self.video.as_ref().map(|v| v.serialize_update(inputs)),
           "audio": self.audio.as_ref().map(|a| a.serialize_update(inputs)),
        })
    }
}

pub struct WhepOutputBuilder {
    name: String,
    bearer_token: Option<String>,
    video: Option<WhepOutputVideoOptions>,
    audio: Option<WhepOutputAudioOptions>,
}

impl WhepOutputBuilder {
    pub fn new() -> Self {
        Self {
            name: "".to_string(),
            bearer_token: None,
            video: None,
            audio: None,
        }
    }

    fn generate_name() -> String {
        static LAST_INPUT: OnceLock<AtomicU32> = OnceLock::new();
        let atomic_suffix = LAST_INPUT.get_or_init(|| AtomicU32::new(0));
        let suffix = atomic_suffix.fetch_add(1, std::sync::atomic::Ordering::Relaxed);

        format!("output_whep_{suffix}")
    }

    pub fn prompt(self) -> Result<Self> {
        let mut builder = self;

        builder = builder.prompt_name()?.prompt_token()?;

        loop {
            builder = builder.prompt_video()?;

            if builder.video.is_none() {
                error!("Video must be specified for WHEP output");
            } else {
                break;
            }
        }
        builder = builder.with_audio(WhepOutputAudioOptions::default());

        Ok(builder)
    }

    fn prompt_name(self) -> Result<Self> {
        let name_input = Text::new("Output name (ESC for autogenerated):").prompt_skippable()?;

        match name_input {
            Some(name) if !name.trim().is_empty() => Ok(self.with_name(name)),
            None | Some(_) => Ok(self.with_name(WhepOutputBuilder::generate_name())),
        }
    }

    fn prompt_token(self) -> Result<Self> {
        let env_token = env::var(WHEP_TOKEN_ENV).unwrap_or_default();
        let default_token = "example";
        let endpoint_token_input =
            Text::new("Enter the WHEP endpoint bearer token (ESC for default):")
                .with_default(default_token)
                .with_initial_value(&env_token)
                .prompt_skippable()?;

        match endpoint_token_input {
            Some(token) => Ok(self.with_bearer_token(token)),
            None => Ok(self.with_bearer_token(default_token.to_string())),
        }
    }

    fn prompt_video(self) -> Result<Self> {
        let video_options = vec![
            WhepRegisterOptions::SetVideoStream,
            WhepRegisterOptions::Skip,
        ];
        let video_selection = Select::new("Set video stream?", video_options).prompt_skippable()?;

        match video_selection {
            Some(WhepRegisterOptions::SetVideoStream) => {
                let mut video = WhepOutputVideoOptions::default();
                let encoder_options = VideoEncoder::iter()
                    .filter(|enc| *enc != VideoEncoder::Any)
                    .collect();

                let encoder_selection =
                    Select::new("Select encoder (ESC for ffmpeg_h264)", encoder_options)
                        .prompt_skippable()?;
                if let Some(encoder) = encoder_selection {
                    video.encoder = encoder;
                }

                let scene_options = Scene::iter().collect();
                let scene_choice =
                    Select::new("Select scene:", scene_options).prompt_skippable()?;
                if let Some(scene) = scene_choice {
                    video.scene = scene;
                }
                Ok(self.with_video(video))
            }
            Some(WhepRegisterOptions::Skip) | None => Ok(self),
            _ => unreachable!(),
        }
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_video(mut self, video: WhepOutputVideoOptions) -> Self {
        self.video = Some(video);
        self
    }

    pub fn with_audio(mut self, audio: WhepOutputAudioOptions) -> Self {
        self.audio = Some(audio);
        self
    }

    pub fn with_bearer_token(mut self, token: String) -> Self {
        self.bearer_token = Some(token);
        self
    }

    pub fn build(self) -> WhepOutput {
        WhepOutput {
            name: self.name,
            bearer_token: self.bearer_token.unwrap(),
            video: self.video,
            audio: self.audio,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WhepOutputVideoOptions {
    resolution: VideoResolution,
    encoder: VideoEncoder,
    root_id: String,
    scene: Scene,
}

impl WhepOutputVideoOptions {
    pub fn serialize_register(&self, inputs: &[&dyn InputHandle]) -> serde_json::Value {
        let inputs = filter_video_inputs(inputs);
        json!({
            "resolution": self.resolution.serialize(),
            "encoder": {
                "type": self.encoder.to_string(),
            },
            "initial": {
                "root": self.scene.serialize(&self.root_id, &inputs, self.resolution),
            },
        })
    }

    pub fn serialize_update(&self, inputs: &[&dyn InputHandle]) -> serde_json::Value {
        let inputs = filter_video_inputs(inputs);
        json!({
            "root": self.scene.serialize(&self.root_id, &inputs, self.resolution),
        })
    }
}

impl Default for WhepOutputVideoOptions {
    fn default() -> Self {
        let resolution = VideoResolution {
            width: 1920,
            height: 1080,
        };
        let root_id = "root".to_string();
        Self {
            resolution,
            encoder: VideoEncoder::FfmpegH264,
            root_id,
            scene: Scene::Tiles,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct WhepOutputAudioOptions {
    encoder: AudioEncoder,
}

impl WhepOutputAudioOptions {
    pub fn serialize_register(&self, inputs: &[&dyn InputHandle]) -> serde_json::Value {
        let inputs_json = inputs
            .iter()
            .filter_map(|input| {
                if input.has_audio() {
                    Some(json!({
                        "input_id": input.name(),
                    }))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();

        json!({
            "encoder": {
                "type": self.encoder.to_string(),
                "preset": "quality",
            },
            "initial": {
                "inputs": inputs_json,
        }
        })
    }

    pub fn serialize_update(&self, inputs: &[&dyn InputHandle]) -> serde_json::Value {
        let inputs_json = inputs
            .iter()
            .filter_map(|input| {
                if input.has_audio() {
                    Some(json!({
                        "input_id": input.name(),
                    }))
                } else {
                    None
                }
            })
            .collect::<Vec<_>>();
        json!({
            "inputs": inputs_json,
        })
    }
}

impl Default for WhepOutputAudioOptions {
    fn default() -> Self {
        Self {
            encoder: AudioEncoder::Opus,
        }
    }
}
