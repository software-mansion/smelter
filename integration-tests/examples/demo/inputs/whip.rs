use std::{
    env,
    sync::{OnceLock, atomic::AtomicU32},
};

use anyhow::Result;
use inquire::{Select, Text};
use integration_tests::paths::integration_tests_root;
use serde::{Deserialize, Serialize};
use serde_json::json;
use strum::IntoEnumIterator;
use tracing::info;

use crate::inputs::{InputHandle, VideoDecoder};

const WHIP_TOKEN_ENV: &str = "WHIP_INPUT_BEARER_TOKEN";

#[derive(Debug, Serialize, Deserialize)]
pub struct WhipInput {
    name: String,
    bearer_token: String,
    video: Option<WhipInputVideoOptions>,
}

#[typetag::serde]
impl InputHandle for WhipInput {
    fn name(&self) -> &str {
        &self.name
    }

    fn serialize_register(&self) -> serde_json::Value {
        json!({
            "type": "whip_server",
            "bearer_token": self.bearer_token,
            "video": self.video.as_ref().map(|v| v.serialize_register()),
        })
    }

    fn has_video(&self) -> bool {
        self.video.is_some()
    }

    fn on_after_registration(&mut self) -> Result<()> {
        let html_path = integration_tests_root().join("examples/demo/whip.html");
        let url = format!(
            "file://{}?url=http://127.0.0.1:9000/whip/{}&token={}",
            html_path.to_str().unwrap(),
            self.name,
            self.bearer_token
        );

        println!("Instructions to start streaming:");
        println!("1. Open OBS Studio");
        println!(
            "2. In a 'Stream' tab enter 'http://127.0.0.1:9000/whip/{}' in 'Server' field and '{}' in 'Bearer Token' field",
            self.name, self.bearer_token
        );
        println!("OR");
        println!("Open in browser:");
        println!("{url}");
        Ok(())
    }
}

pub struct WhipInputBuilder {
    name: String,
    bearer_token: String,
    video: Option<WhipInputVideoOptions>,
}

impl WhipInputBuilder {
    pub fn new() -> Self {
        Self {
            name: String::new(),
            bearer_token: "example".to_string(),
            video: None,
        }
    }

    fn generate_name() -> String {
        static LAST_INPUT: OnceLock<AtomicU32> = OnceLock::new();
        let atomic_suffix = LAST_INPUT.get_or_init(|| AtomicU32::new(0));
        let suffix = atomic_suffix.fetch_add(1, std::sync::atomic::Ordering::Relaxed);

        format!("input_whip_{suffix}")
    }

    pub fn prompt(self) -> Result<Self> {
        self.prompt_name()?.prompt_bearer_token()?.prompt_video()
    }

    fn prompt_name(self) -> Result<Self> {
        let name_input = Text::new("Input name (ESC for autogenerated):").prompt_skippable()?;

        match name_input {
            Some(name) if !name.trim().is_empty() => Ok(self.with_name(name)),
            None | Some(_) => Ok(self.with_name(WhipInputBuilder::generate_name())),
        }
    }

    // It doesn't actually prompt, but is used in chain
    fn prompt_bearer_token(self) -> Result<Self> {
        match env::var(WHIP_TOKEN_ENV).ok() {
            Some(token) => {
                info!("WHIP bearer token read from env: {token}");
                Ok(self.with_bearer_token(token))
            }
            None => {
                info!("Using default WHIP bearer token '{}'", self.bearer_token);
                Ok(self)
            }
        }
    }

    fn prompt_video(self) -> Result<Self> {
        let mut video = WhipInputVideoOptions::default();

        let mut decoder_options = VideoDecoder::iter().collect::<Vec<_>>();
        let mut decoder_preferences = vec![];
        loop {
            let decoder_selection = Select::new(
                "Select decoder (ESC or Any to progress):",
                decoder_options.clone(),
            )
            .prompt_skippable()?;

            match decoder_selection {
                Some(decoder) => {
                    decoder_preferences.push(decoder);
                    if decoder == VideoDecoder::Any {
                        break;
                    } else {
                        decoder_options.retain(|dec| *dec != decoder);
                    }
                }
                None => break,
            }
        }
        video.decoder_preferences = decoder_preferences;

        Ok(self.with_video(video))
    }

    pub fn with_name(mut self, name: String) -> Self {
        self.name = name;
        self
    }

    pub fn with_video(mut self, video: WhipInputVideoOptions) -> Self {
        self.video = Some(video);
        self
    }

    pub fn with_bearer_token(mut self, token: String) -> Self {
        self.bearer_token = token;
        self
    }

    pub fn build(self) -> WhipInput {
        WhipInput {
            name: self.name,
            bearer_token: self.bearer_token,
            video: self.video,
        }
    }
}

#[derive(Debug, Serialize, Deserialize, Default)]
pub struct WhipInputVideoOptions {
    decoder_preferences: Vec<VideoDecoder>,
}

impl WhipInputVideoOptions {
    pub fn serialize_register(&self) -> serde_json::Value {
        json!({
            "decoder_preferences": self.decoder_preferences.iter().map(|dec| dec.to_string()).collect::<Vec<_>>(),
        })
    }
}
